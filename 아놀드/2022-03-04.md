# 클린 아키텍처

## 독립성 (160 ~ 167)

### 유스케이스 결합 분리

- 시스템을 수평적 계층으로 분할하고, 해당 계층을 수직으로 가로질러 시스템을 분할한다
- 서로 다른 이유로 변경되는 요소의 결합을 분리하게 유스케이스를 작성하면
  기존 요소에 영향을 안 주고, 새로운 유스케이스를 쉽게 추가할 수 있다

### 개발 독립성

- ui와 업무 규칙을 분리하고, 유스케이스도 결합을 분리하면 독립적으로 개발할 수 있다

### 배포 독립성

- 결합 분리를 잘했다면, 런타임 중에도 배포할 수 있다

### 중복

- 중복은 '진짜 중복', '우발적 중복'으로 나뉜다
- 우발적 중복은 처음엔 진짜 중복 같지만, 추후에 다른 방향으로 발전하는 코드다
  ex) 추가뷰와 수정뷰가 비슷해보이니, 코드도 합치고 싶은 유혹이 있지만
  서비스가 발전하면서 둘은 다른 형태로 발전한다
  그 때 분리하는 작업을 하면 매우 고통스럽다

### 결합 분리 모드 (이 부분은 너무 추상적이여서 아직도 이해를 잘 못하겠다... 별표 돼지 꼬리 땡땡땡)

## 경계: 선 긋기 (170 ~ 183)

- 아키텍처는 선을 긋는 기술이다

### 어떻게 선을 그을까?

- 관련이 있는 것과 없는 것 사이에 긋는다.
  ex) GUI와 업무 규칙, 데이터베이스와 업무 규칙

### 입력과 출력은 중요한가?

- 전혀 안 중요하다
  중요한 건 내부에 자리잡은 정책이다
  정책은 입출력 컴포넌트를 모르게 작성하면
  다른 입출력 세부사항으로 바꿀 수 있다.
  ex) GUI, 콘솔, 게임, 웹

### 플러그인 아키텍처

- 핵심 정책이 기타 세부사항과 분리되고, 독립적이라면 가능하다
- 다른 세부사항이 변화가 전파될 수 없도록 방화벽이 생성된다
  EX) 마인크래프트에 모드 깔기, 운영체제 입출력
  서비스 중인 소프트웨어에 DB를 MY_SQL에서 NO_SQL로 변환하는 일

### 결론

- 이 모두가 SRP(단일 책임 원칙)을 준수해서 컴포넌트를 결합, 분리하고
  DIP(의존성 역전 원칙)과 SAP(안정된 추상화 원칙)을 이용하여,
  저수준 세부사항이 고수준 추상화를 의존하도록 하여 만들어진다

## 느낀점

- 유스케이스를 나누는 방법이 인상 깊다. E2E 테스트로 써먹어야겠다
- 예전에 추가, 수정폼을 하나로 묶었다가 다시 분리했었던 경험이 있어서
  우발적 중복 이야기에 매우 공감했다
- 의존되는 컴포넌트는 의존하는 컴포넌트를 모르게 하면 유연한 아키텍처가 나오는 내용이 인상 깊었다.
  왜냐하면 객체지향에서도 객체끼리는 자신만의 일을 할 뿐 다른 객체가 뭘하는지 몰라도 되고,
  함수형 프로그래밍에서도 파이프라인안에 나열된 함수들은 각자 자기일만 하고,
  다음 함수에게 인자를 넘겨줄 뿐, 뭔 일을 하는지, 누가 있는지도 모른다.
  이처럼 의존성을 헐겁게 하는 방식이 함수 작성, 클래스 작성에서부터
  고수준인 아키텍처까지 통용되는 게 인상 깊었다
